



Internet Engineering Task Force (IETF)                      B. Perriello
Request for Comments: 553                                               
Category: Informational                                            K. Ko
ISSN: 2070-1721                                            21 April 2021


                      Protocol for Penn Streaming

Abstract

   This document specifies a new protocol for a music streaming service
   in which a server with music files responds to client requests for
   music.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are candidates for any level of Internet
   Standard; see Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   https://www.rfc-editor.org/info/rfc553.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction
     1.1.  Terminology
   2.  Messages
     2.1.  Message Types
     2.2.  Message Formatting - Text vs. Binary
     2.3.  Message Formatting - Message Delimiters
   3.  State
     3.1.  State the server should store per-client
     3.2.  How messages enable state transitions
   4.  Performance Considerations
   5.  Acknowledgements

1.  Introduction

   The design and the implementation of this protocol informs users the
   concerns behind constructing different protocols for streaming
   services.  Common constraints that are involved are header and
   message formats, proper framing of messages, and the behavior between
   the client and server in response to a message.

   While the protocol by no means describes the complication of such
   protocols like RTSP or DASH chunking, it still educates users with
   the basic ideas of message types, message formatting, and server and
   client state transitions involved in streaming.

1.1.  Terminology

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in RFC2119.

2.  Messages

2.1.  Message Types

   At a minimum, the protocol SHOULD handle the following messages.
   These messages are similar to those of RTSP.

   Client messages:

   *  setup : request to connect with the server

   *  list : request the list of songs existing in the server

   *  play : request to play a certain song

   *  stop : request the server to pause sending data packets

   *  teardown : request to disconnect with the server

   Server messages:

   *  list : return the list of songs existing in the server

   *  play : provide the client with chunks of data for the specified
      song

   *  stop : stop providing client with chunks of data for the specified
      song

   *  error : tell the client that an error has occurred (e.g. song does
      not exist)

2.2.  Message Formatting - Text vs. Binary

   The client and server will use packets that store information about
   message types (e.g. list, play), song number, timestamps, and data in
   text format.

   When sending over packets, only necessary components (e.g. client
   does not need to send over the 'data' attribute) are stringified,
   sent, and decoded back to a packet at the other end.

2.3.  Message Formatting - Message Delimiters

   Attributes of a single packet can be stringified to a string
   delimited by <NEXT;>.  Note that the string MAY be delimited in other
   ways.

   Client --> Server Example:

   *  play<NEXT;>song number<NEXT;>timestamp<NEXT;><END;>

   Server --> Client Example:

   *  play<NEXT;>song number<NEXT;>timestamp<NEXT;>data<NEXT;><END;>

   Each packet starts with a message type, and an <END;> phrase is used
   to mark the end of a message.

3.  State

3.1.  State the server should store per-client

   The server MUST keep track of the following:

   *  connected : the server MUST make sure that the client has an
      established connection

   *  song number : the server MUST keep track of what the client is
      currently listening to

   *  timestamp : the server MUST keep track of what chunk the client is
      listening to

   *  play/stop : the server MUST keep track of whether the client wants
      to play or stop a song

3.2.  How messages enable state transitions

   Different message types render the state of the client and server in
   different ways.

   Client receives from Server:

   *  list : takes priority over playing, lists the songs, and then
      resumes current state

   *  play : play music state

   *  stop : takes priority over playing, stops the current song, and
      move to pause state

   *  error : notifies the client and then resumes current state

   Server receives from Client:

   *  setup : server starts maintaining an open connection with the
      client

   *  list : maintains the current state

   *  play : server starts transmitting data of a specified song

   *  stop : server stops transmitting data

   *  teardown : server takes priority over any other state and changes
      to a closed state

4.  Performance Considerations

   *  The "list" command *MIGHT* very briefly pause a song because it
      takes priority over a "play" state

   *  Since strings are REQUIRED to be delimited by <NEXT;>, our
      assumption is that there are no "song number" or "data" values
      that are <NEXT;>

5.  Acknowledgements

   The authors wish to thank the teaching assistants for reading this
   documentation.
