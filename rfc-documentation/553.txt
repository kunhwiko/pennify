



Internet Engineering Task Force (IETF)                      B. Perriello
Request for Comments: 553                                               
Category: Informational                                            K. Ko
ISSN: 2070-1721                                               4 May 2021


                      Protocol for Penn Streaming

Abstract

   This document specifies a new protocol for a music streaming service
   in which a server with music files responds to client requests for
   music.

Status of This Memo

   This document is not an Internet Standards Track specification; it is
   published for informational purposes.

   This document is a product of the Internet Engineering Task Force
   (IETF).  It represents the consensus of the IETF community.  It has
   received public review and has been approved for publication by the
   Internet Engineering Steering Group (IESG).  Not all documents
   approved by the IESG are candidates for any level of Internet
   Standard; see Section 2 of RFC 7841.

   Information about the current status of this document, any errata,
   and how to provide feedback on it may be obtained at
   https://www.rfc-editor.org/info/rfc553.

Copyright Notice

   Copyright (c) 2021 IETF Trust and the persons identified as the
   document authors.  All rights reserved.

   This document is subject to BCP 78 and the IETF Trust's Legal
   Provisions Relating to IETF Documents
   (https://trustee.ietf.org/license-info) in effect on the date of
   publication of this document.  Please review these documents
   carefully, as they describe your rights and restrictions with respect
   to this document.  Code Components extracted from this document must
   include Simplified BSD License text as described in Section 4.e of
   the Trust Legal Provisions and are provided without warranty as
   described in the Simplified BSD License.

Table of Contents

   1.  Introduction
     1.1.  Terminology
   2.  Messages
     2.1.  Message Types
     2.2.  Message Formatting - Text vs. Binary
     2.3.  Message Formatting - Message Delimiters
   3.  State
     3.1.  Client State
     3.2.  Server State
     3.3.  State Transitions
   4.  Streaming
     4.1.  Step 1 : Creating a Client Request
     4.2.  Step 2 : Processing Server Response
     4.3.  Step 3: Processing Client Response
   5.  Performance Considerations
   6.  Acknowledgements

1.  Introduction

   The design and the implementation of this protocol informs users the
   concerns behind constructing different protocols for streaming
   services.  Common constraints that are involved are header and
   message formats, proper framing of messages, and the behavior between
   the client and server in response to a message.

   While the protocol by no means describes the complication of such
   protocols like RTSP or DASH chunking, it still educates users with
   the basic ideas of message types, message formatting, and server and
   client state transitions involved in streaming.

1.1.  Terminology

   The keywords MUST, MUST NOT, REQUIRED, SHALL, SHALL NOT, SHOULD,
   SHOULD NOT, RECOMMENDED, MAY, and OPTIONAL, when they appear in this
   document, are to be interpreted as described in RFC2119.

2.  Messages

2.1.  Message Types

   At a minimum, the protocol SHOULD handle the following messages.
   These messages are similar to those of RTSP.

   Client requests:

   *  list : request the list of songs existing in the server and their
      ID number

   *  play (song id) : request to play a certain song, a song id must be
      specified

   *  stop : request the server to stop sending data

   *  quit : request to disconnect with the server

   Server responses:

   *  list : return the list of songs existing in the server and their
      ID number

   *  play : provide the client with chunks of data for the specified
      song

   *  stop : stop providing client with chunks of data for the specified
      song

   There are some key points to note.  Upon a client quit request, the
   server SHALL NOT send any response back to the client.  If the client
   is able to exit gracefully, this indicates that the quit request has
   been properly executed.

   If a non-existant song ID is provided by the user, the server SHALL
   NOT send a response back to the client.

2.2.  Message Formatting - Text vs. Binary

   The client and server SHALL communicate using packets to store
   information about message types (e.g. list, play), song ID, and data
   in text format.

   When transmitting packets, only necessary components are stringified,
   sent, and decoded back to a packet at the other end.  As an example,
   when the client sends a list request, the song ID and the data
   attribute MAY not need to be shared with the server.

2.3.  Message Formatting - Message Delimiters

   Attributes of a single packet SHALL be stringified to a string
   delimited by <NEXT;>, and the end of the string MUST be noted as
   <END;>.  Note that the string MAY be delimited in other ways.

   To reassemble back to a packet structure, simply split the string by
   <NEXT;> and assign the information to a new packet.

   Client --> Server Example:

   *  play<NEXT;>song ID<NEXT;><END;>

   Server --> Client Example:

   *  play<NEXT;>data<NEXT;><END;>

3.  State

3.1.  Client State

   The client MUST keep track of the following:

   *  current song : the current song that is being played on the client
      side

   *  current play : boolean flag to specify whether or not a song is
      currently being played

   *  connection : sock.connect() will check to see if the server is
      accessible

3.2.  Server State

   The server MUST keep track of the following:

   *  client : information about clients the server is connected to

   For each client class within the server, the following information
   MUST be stored:

   *  lock : locks access to this client information

   *  connection : used to connect to a client and send responses back

   *  directory : the directory to the music file

   *  songlist : list of songs the server has

   *  current song : the current song that is being played on the client
      side

   *  packet queue : queue with packets that will be processed and sent
      back to the client

3.3.  State Transitions

   Different message types render the state of the client and server in
   different ways.

   Client receives from Server:

   *  list : does not change the current state, a list will be printed
      concurrently

   *  play : takes priority over current state, stops the current song,
      and renders to music playing state

   *  stop : takes priority over current state, stops the current song,
      and renders to stop state

   Server receives from Client:

   *  setup : typically done through a valid sock.connect() on the
      client side, the server will create a new instance of the Client
      class to maintain information

   *  list : maintains the current state

   *  play : server starts transmitting data of a specified song

   *  stop : server stops transmitting data

   *  quit : server takes priority over any other state and closes
      connection to client

4.  Streaming

4.1.  Step 1 : Creating a Client Request

   Once a connection has been established through sock.connect(), the
   client is ready to send a request.  All invalid commands will be
   discarded, and once a valid command has been inputted by the user, a
   packet will be generated.  This packet holds information on the
   message type and the song ID (if any).

   Once the packet has been generated, it SHOULD be encoded into a
   string with the format mentioned in the "Message" section of this
   document and then sent over to the server.

4.2.  Step 2 : Processing Server Response

   Once a string has been received from the client, the server MUST
   decode the string back into a packet.  The server will then process
   the packet to observe the message type and song ID (if any).

   If a list or play request is to be processed, the server SHALL inject
   data into the packet.  For list requests, this SHOULD be the list of
   songs and for play requests, this SHOULD be the raw data of music
   files.  Typically, music files tend to have a higher capacity than
   the send buffer, and must be sent in separate chunks.  Please see the
   "Performance Consideration" section of this document for details.

   Once the injection process is finished, the packet is then decoded
   into a string and sent to the client.

4.3.  Step 3: Processing Client Response

   Once a string has been received from the server, the client MUST
   decode the string back into a packet.  The client will then process
   the packet to observe the message type and data (if any).

   If a play request had been issued, the music data will be buffered as
   much as the receive buffer can handle.  Once the client observes that
   a packet has data, it will output that data.

5.  Performance Considerations

   *  The "play" command SHALL first issue a stop request, sleep for a
      short period to process the packet, and then reissue a play
      request.  A sleep period is important as without it MAY create a
      collision between the stop and play requests.

   *  Since strings are REQUIRED to be delimited by <NEXT;>, our
      assumption is that there are no "song IDs" or "data" values that
      are <NEXT;>

   *  The max buffer size on both the server and client SHALL be capped
      at 4096.  The music data itself MUST be capped at 4072 when
      sending from the server to the client to provide sufficient space
      for other parts of the message such as message types and
      delimiters.

6.  Acknowledgements

   The authors wish to thank the teaching assistants for reading this
   documentation.
