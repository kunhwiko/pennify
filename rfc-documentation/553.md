%%%
Title = "Protocol for Penn Streaming"
abbrev = "Protocol for Penn Streaming"
ipr= "trust200902"
area = "Internet"
workgroup = "Network Working Group"
submissiontype = "IETF"
keyword = [""]
#date = 2021-05-04T00:00:00Z

[seriesInfo]
name = "RFC"
value = "553"
stream = "IETF"
status = "informational"

[[author]]
initials="B."
surname="Perriello"
fullname="Brian Perriello"
 [author.address]
 email = "bperr@seas.upenn.edu"
  [author.address.postal]
  city = "Philadelphia"
  country = "United States of America"
[[author]]
initials="K."
surname="Ko"
fullname="Kun Hwi Ko"
 [author.address]
 email = "kunko@seas.upenn.edu"
  [author.address.postal]
  city = "Santa Clara"
  country = "United States of America"
%%%

.# Abstract

This document specifies a new protocol for a music streaming service in which a server with music files responds to client requests for music.

{mainmatter}

# Introduction

The design and the implementation of this protocol informs users the concerns behind constructing different protocols for streaming services. Common constraints that are involved are header and message formats, proper framing of messages, and the behavior between the client and server in response to a message. 

While the protocol by no means describes the complication of such protocols like RTSP or DASH chunking, it still educates users with the basic ideas of message types, message formatting, and server and client state transitions involved in streaming.  

## Terminology

The keywords **MUST**, **MUST NOT**, **REQUIRED**, **SHALL**, **SHALL NOT**, **SHOULD**,
**SHOULD NOT**, **RECOMMENDED**, **MAY**, and **OPTIONAL**, when they appear in this document, are
 to be interpreted as described in RFC2119.

# Messages

## Message Types

At a minimum, the protocol **SHOULD** handle the following messages. These messages are similar to those of RTSP.

Client requests:\

  - list : request the list of songs existing in the server and their ID number\

  - play (song id) : request to play a certain song, a song id must be specified\

  - stop : request the server to stop sending data\

  - quit : request to disconnect with the server\


Server responses:\

  - list : return the list of songs existing in the server and their ID number\

  - play : provide the client with chunks of data for the specified song\

  - stop : stop providing client with chunks of data for the specified song\ 


There are some key points to note. Upon a client quit request, the server **SHALL NOT** send a response back to the client. If the client is able to exit gracefully, this indicates that the quit request has been properly executed.   

If a non-existant song ID is provided by the user, the server **SHALL NOT** send a response back to the client.  


## Message Formatting - Text vs. Binary

The client and server **SHALL** communicate using packets to store information about message types (e.g. list, play), song ID, and data in text format.

When transmitting packets, only necessary components are stringified, sent, and decoded back to a packet at the other end. As an example, when the client sends a list request, the song ID and the data attribute **MAY** not need to be shared with the server. 


## Message Formatting - Message Delimiters

Attributes of a single packet **SHALL** be stringified to a string delimited by <NEXT;>, and the end of the string **MUST** be noted as <END;>. Note that the string **MAY** be delimited in other ways. 

To reassemble back to a packet structure, simply split the string by <NEXT;> and assign the information to a new packet.  

Client --> Server Example:\

  
  - play<NEXT;>song ID<NEXT;><END;>\


Server --> Client Example:\

  
  - play<NEXT;>data<NEXT;><END;>\


# State

## Client State 

The client **MUST** keep track of the following:\

  - current song : the current song that is being played on the client side\

  - current play : boolean flag to specify whether or not a song is currently being played\

  - connection : sock.connect() will check to see if the server is accessible\


## Server State 

The server **MUST** keep track of the following:\

  - client : information about clients the server is connected to\

For each client class within the server, the following information **MUST** be stored:\

  - lock : locks access to this client information\

  - connection : used to connect to a client and send responses back\

  - directory : the directory to the music file\

  - songlist : list of songs the server has\

  - current song : the current song that is being played on the client side\

  - packet queue : queue with packets that will be processed and sent back to the client\


## State Transitions 

Different message types render the state of the client and server in different ways.\ 

Client receives from Server:\
  
  - list : does not change the current state, a list will be printed concurrently\ 

  - play : takes priority over current state, stops the current song, and renders to music playing state\

  - stop : takes priority over current state, stops the current song, and renders to stop state\

Server receives from Client:\

  - setup : typically done through a valid sock.connect() on the client side, the server will create a new instance of the Client class to maintain information\

  - list : maintains the current state\ 

  - play : server starts transmitting data of a specified song\

  - stop : server stops transmitting data\

  - quit : server takes priority over any other state and closes connection to client\ 

# Streaming

## Step 1 : Creating a Client Request

Once a connection has been established through sock.connect(), the client is ready to send a request. All invalid commands will be discarded, and once a valid command has been inputted by the user, a packet will be generated. This packet holds information on the message type and the song ID (if any). 

Once the packet has been generated, it **SHOULD** be encoded into a string with the format mentioned in the "Message" section of this document and then sent over to the server.

## Step 2 : Processing Server Response 

Once a string has been received from the client, the server **MUST** decode the string back into a packet. The server will then process the packet to observe the message type and song ID (if any). 

If a list or play request is to be processed, the server **SHALL** inject data into the packet. For list requests, this **SHOULD** be the list of songs and for play requests, this **SHOULD** be the raw data of music files. Typically, music files tend to have a higher capacity than the send buffer, and must be sent in separate chunks. Please see the "Performance Consideration" section of this document for details. 

Once the injection process is finished, the packet is then decoded into a string and sent to the client.

## Step 3: Processing Client Response 

Once a string has been received from the server, the client **MUST** decode the string back into a packet. The client will then process the packet to observe the message type and data (if any). 

If a play request had been issued, the music data will be buffered as much as the receive buffer can handle. Once the client observes that a packet has data, it will output that data.  

# Performance Considerations

  - The "play" command **SHALL** first issue a stop request, sleep for a short period to process the packet, and then reissue a play request. A sleep period is important as without it **MAY** create a collision between the stop and play requests.\

  - Since strings are **REQUIRED** to be delimited by <NEXT;>, our assumption is that there are no "song IDs" or "data" values that are <NEXT;>\

  - The max buffer size on both the server and client **SHALL** be capped at 4096. The music data itself **MUST** be capped at 4072 when sending from the server to the client to provide sufficient space for other parts of the message such as message types and delimiters.    

# Acknowledgements

The authors wish to thank the teaching assistants for reading this documentation. 

